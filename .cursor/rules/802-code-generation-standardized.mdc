---
description: "ALWAYS APPLY when GENERATING or MODIFYING code to ENSURE efficiency, maintainability and adherence to project standards"
globs: "**/*.{js,ts,jsx,tsx,java,py,html,css,scss}"
---
---
title: "Workflow Agile Standard"
version: "2.0.0"
description: "ALWAYS FOLLOW this workflow for ALL projects to ENSURE consistent agile delivery and documentation"
globs: "**/*.{md,js,ts,jsx,tsx}"
alwaysApply: true
priority: 90
compatibility: ">=0.45"
lastUpdated: "2025-03-10"
tags: ["workflow", "agile", "planning", "documentation"]
---

# üß© Standard de G√©n√©ration de Code Excellence

## üìã Vue d'Ensemble
Cette r√®gle d√©finit les bonnes pratiques √† suivre lors de la g√©n√©ration ou modification de code dans un contexte de base de code vaste. Elle vise √† garantir que le code produit soit simple, efficace, maintenable et strictement align√© avec les exigences document√©es dans les stories et les documents d'architecture, tout en suivant les principes SOLID, DDD et Clean Architecture.

> ‚ö†Ô∏è **Attention**: Cette r√®gle est fondamentale pour maintenir la qualit√© du code et √©viter la dette technique. Toute d√©viation doit √™tre justifi√©e par un argumentaire technique robuste.

## üéØ Objectifs
- Assurer que le code g√©n√©r√© est minimal et focalis√© sur les exigences actuelles
- Pr√©venir la sur-ing√©nierie et les complexit√©s inutiles
- Garantir l'alignement avec l'architecture et les stories d√©finies
- √âviter les hallucinations et les suppositions non-document√©es
- Maintenir la coh√©rence avec les conventions du projet
- Respecter les principes SOLID, DDD et Clean Architecture

## üìè Principes Fondamentaux

### Simplicit√© et Efficacit√©
- **KISS (Keep It Simple, Stupid)**: Pr√©f√©rez toujours la solution la plus simple qui r√©sout le probl√®me.
- **YAGNI (You Aren't Gonna Need It)**: N'ajoutez pas de fonctionnalit√©s "au cas o√π" - impl√©mentez uniquement ce qui est demand√© maintenant.
- **DRY (Don't Repeat Yourself)**: √âvitez la duplication de code, mais ne cr√©ez pas d'abstractions pr√©matur√©es.

### Principes SOLID
- **Single Responsibility Principle**: Chaque classe/module ne doit avoir qu'une seule raison de changer.
- **Open/Closed Principle**: Les entit√©s doivent √™tre ouvertes √† l'extension mais ferm√©es √† la modification.
- **Liskov Substitution Principle**: Les objets d'une classe d√©riv√©e doivent pouvoir remplacer les objets de la classe de base sans alt√©rer la correction du programme.
- **Interface Segregation Principle**: Pr√©f√©rez plusieurs interfaces sp√©cifiques plut√¥t qu'une interface g√©n√©rale.
- **Dependency Inversion Principle**: D√©pendez des abstractions, pas des impl√©mentations concr√®tes.

### Clean Architecture & DDD
- S√©parez clairement les couches d'infrastructure, d'application, de domaine et de pr√©sentation
- Concentrez la logique m√©tier dans la couche domaine, ind√©pendante des frameworks et outils
- Utilisez des mod√®les ubiquitaires (Ubiquitous Language) refl√©tant le vocabulaire du domaine m√©tier
- Impl√©mentez des entit√©s riches encapsulant la logique m√©tier plut√¥t que des structures de donn√©es an√©miques
- D√©finissez des agr√©gats et leurs limites (Bounded Contexts) pour maintenir la coh√©rence des donn√©es

### Minimalisme Cibl√©
- G√©n√©rez uniquement le code n√©cessaire √† l'impl√©mentation de la story/task actuelle
- Limitez la cr√©ation de nouveaux fichiers au strict n√©cessaire
- √âvitez d'anticiper des besoins futurs non sp√©cifi√©s dans les documents du projet

### Coh√©rence Contextuelle
- Consultez syst√©matiquement les documents de r√©f√©rence avant toute g√©n√©ration
- Respectez l'architecture existante et les patterns √©tablis
- R√©f√©rez-vous toujours aux crit√®res d'acceptation de la story en cours

## ‚úÖ Pratiques Recommand√©es

### Avant de G√©n√©rer du Code
1. **Analysez la story/task** pour comprendre pr√©cis√©ment son p√©rim√®tre
2. **Consultez le document d'architecture** pour identifier les patterns √† suivre
3. **Examinez le code existant** pour maintenir la coh√©rence stylistique
4. **Identifiez les bounded contexts** concern√©s par votre impl√©mentation

### Pendant la G√©n√©ration
1. **Privil√©giez la lisibilit√©** sur l'optimisation pr√©matur√©e
2. **Commentez les d√©cisions complexes** pour faciliter la maintenance
3. **Testez au fur et √† mesure** pour valider que le code r√©pond aux exigences
4. **Respectez la s√©paration des pr√©occupations** en suivant Clean Architecture
5. **Appliquez les principes SOLID** dans la conception des classes et interfaces

### Apr√®s la G√©n√©ration
1. **R√©visez le code** pour √©liminer tout √©l√©ment non n√©cessaire
2. **V√©rifiez l'alignement** avec les crit√®res d'acceptation
3. **Documentez les choix d'impl√©mentation** importants
4. **Validez le respect** des principes architecturaux (SOLID, DDD, Clean Architecture)

## ‚ùå Anti-Patterns √† √âviter

### G√©n√©ration Excessive
- Cr√©ation de fichiers "qui pourraient √™tre utiles plus tard"
- Impl√©mentation de fonctionnalit√©s non sp√©cifi√©es dans la story
- Ajout de code "au cas o√π" ou pour des sc√©narios hypoth√©tiques

### Sur-Ing√©nierie
- Abstractions complexes pour des cas simples
- Optimisations pr√©matur√©es sans donn√©es de performance
- Frameworks ou librairies suppl√©mentaires non justifi√©s

### Hallucinations
- Suppositions sur des exigences non document√©es
- Invention de fonctionnalit√©s non demand√©es
- Ignorance des contraintes sp√©cifi√©es dans les documents du projet

### Violations des Principes Architecturaux
- M√©lange des responsabilit√©s entre couches architecturales
- D√©pendances directes vers les d√©tails d'impl√©mentation
- Mod√®les de domaine an√©miques sans comportement
- Classes monolithiques avec trop de responsabilit√©s

## üîÑ Int√©gration avec le Workflow
Cette r√®gle doit √™tre appliqu√©e √† chaque √©tape du cycle de d√©veloppement d√©fini dans la r√®gle `801-workflow-agile-standardized`. Elle est particuli√®rement importante lors de:
1. L'impl√©mentation des stories
2. La r√©solution des bugs
3. Les revues de code
4. Les refactorisations

## Exemples

<example>
// Bon exemple - Application des principes SOLID
// Single Responsibility Principle
class UserRepository {
  constructor(private dataSource: DataSource) {}
  
  async findById(id: string): Promise<User> {
    return this.dataSource.findUser(id);
  }
  
  async save(user: User): Promise<void> {
    return this.dataSource.saveUser(user);
  }
}

// Open/Closed & Dependency Inversion Principles
interface EmailService {
  sendEmail(to: string, subject: string, body: string): Promise<void>;
}

class UserRegistrationService {
  constructor(
    private userRepository: UserRepository,
    private emailService: EmailService
  ) {}

  async registerUser(userData: UserRegistrationData): Promise<User> {
    // Validation
    if (!userData.email || !userData.password) {
      throw new ValidationError('Email and password are required');
    }
    
    // Domain logic
    const user = new User(userData);
    await this.userRepository.save(user);
    
    // Notification
    await this.emailService.sendEmail(
      user.email,
      'Welcome to our platform',
      `Hello ${user.name}, thank you for registering!`
    );
    
    return user;
  }
}
</example>

<example type="invalid">
// Mauvais exemple - Violation des principes
class UserService {
  // Trop de responsabilit√©s (violation du SRP)
  // D√©pendances directes (violation du DIP)
  constructor() {
    this.db = new MySQLConnection();
    this.emailSender = new SMTPEmailSender();
    this.logger = new FileLogger();
  }
  
  async registerUser(data) {
    // Validation, logique m√©tier, persistance et notification
    // tout m√©lang√© dans une seule m√©thode
    this.logger.log('Registering user', data);
    
    // Validation insuffisante
    if (!data.email) return false;
    
    // Acc√®s direct √† la base de donn√©es
    await this.db.query(`INSERT INTO users VALUES (${data.id}, ${data.name}, ${data.email})`);
    
    // Envoi d'email hardcod√©
    await this.emailSender.send(data.email, 'Welcome', 'Thanks for registering!');
    
    return true;
  }
  
  // Autres m√©thodes non li√©es dans la m√™me classe
  async updateUserProfile() { /* ... */ }
  async resetPassword() { /* ... */ }
  async sendNewsletters() { /* ... */ }
  async generateReports() { /* ... */ }
}
</example>

<version>2.0.0</version>