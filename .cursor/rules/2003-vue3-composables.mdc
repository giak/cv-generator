---
description: "ENFORCE extraction de logique dans des composables Vue.js 3 pour GARANTIR r√©utilisabilit√© et maintenabilit√©"
globs: "**/*.{vue,ts,js}"
alwaysApply: false
---

# Vue.js 3 Composables Standards

## Contexte
- Appliquer cette r√®gle lors de la cr√©ation de composants Vue.js 3 avec Composition API
- Extraire la logique r√©utilisable ou complexe dans des composables
- Suivre les principes de Clean Architecture en s√©parant l'UI et la logique
- Privil√©gier les composables pour encapsuler la logique m√©tier et les effets secondaires
- Respecter les contraintes de performance (<500ms) et de simplicit√© du projet

## Requirements
- Nommer les composables avec le pr√©fixe `use` suivi d'un nom descriptif en camelCase (ex: `useFormValidation`)
- Extraire la logique dans des composables quand elle est utilis√©e dans plusieurs composants
- Extraire la logique dans des composables quand elle complexifie un composant (>100 lignes)
- G√©rer correctement le cycle de vie avec `onMounted`, `onUnmounted`, etc.
- Retourner uniquement les donn√©es et m√©thodes n√©cessaires (interface minimaliste)
- Documenter clairement l'interface du composable (param√®tres et valeurs retourn√©es)
- Supporter les param√®tres de type ref ou getter avec `toValue()`
- Placer les composables dans des fichiers s√©par√©s class√©s par domaine fonctionnel
- √âviter de cr√©er des composables pour des extractions triviales (<10 lignes)
- Respecter les principes SOLID, en particulier la responsabilit√© unique
- Assurer la coh√©rence entre composables li√©s (ex: navigation et rendu conditionnel)
- Pr√©voir tous les cas de mapping d'identifiants dans les composables de navigation
- S'assurer que les valeurs retourn√©es par les composables sont utilis√©es correctement dans les templates

## Test-Driven Development
- √âcrire des tests unitaires avant l'impl√©mentation des composables
- Tester toutes les entr√©es et sorties du composable de fa√ßon isol√©e
- Utiliser `vitest` et l'√©cosyst√®me Vue Test Utils pour les tests
- Mocker les d√©pendances externes (stores, API, etc.) pour isoler les tests
- Tester les conditions limites et les cas d'erreur
- V√©rifier les transformations et mappings (ex: 'experience' ‚Üí 'work')
- Pour les composables de navigation:
  - Tester la coh√©rence entre les identifiants fournis et les √©tats r√©sultants
  - V√©rifier que tous les √©tats possibles sont correctement g√©r√©s
  - Tester les fonctions de mise √† jour des miettes de pain (breadcrumbs)
- Pour les composables d'√©tat:
  - Tester l'initialisation des √©tats
  - V√©rifier les mises √† jour d'√©tat
  - Tester les actions de sauvegarde
- Impl√©menter des tests d'int√©gration pour v√©rifier l'interaction entre composables

## Exemples
<example>
// Bon exemple: Composable pour la validation de formulaire (use case)
// useResumeValidator.ts
import { computed } from 'vue'
import { toValue } from 'vue'
import { z } from 'zod'
import { resumeSchema } from '@/core/schemas/resume.schema'

/**
 * Composable pour valider les donn√©es d'un CV selon le sch√©ma JSON Resume
 * @param {Ref<object> | object} resumeData - Donn√©es du CV (ref, computed ou valeur directe)
 * @returns {{
 *   isValid: ComputedRef<boolean>,
 *   errors: ComputedRef<Array<{path: string, message: string}>>,
 *   validate: () => {valid: boolean, errors: Array}
 * }}
 */
export function useResumeValidator(resumeData) {
  // Accepte resumeData comme ref, computed ou valeur directe
  const validate = () => {
    const data = toValue(resumeData)
    try {
      resumeSchema.parse(data)
      return { valid: true, errors: [] }
    } catch (error) {
      if (error instanceof z.ZodError) {
        return { 
          valid: false, 
          errors: error.errors.map(err => ({
            path: err.path.join('.'),
            message: err.message
          }))
        }
      }
      throw error
    }
  }
  
  const isValid = computed(() => validate().valid)
  const errors = computed(() => validate().errors)
  
  return {
    isValid,
    errors,
    validate
  }
}

// Utilisation dans un composant
<script setup>
import { useResumeValidator } from '@/composables/useResumeValidator'
import { useResumeStore } from '@/stores/resume'

const resumeStore = useResumeStore()
const { isValid, errors } = useResumeValidator(resumeStore.resume)
</script>
</example>

<example>
// Bon exemple: Composable de navigation avec mappings d'identifiants
// useNavigation.ts
import { ref, computed } from 'vue'
import type { Component } from 'vue'

export interface NavItem {
  id: string
  label: string
  path: string
  active?: boolean
  icon?: string
}

export function useNavigation(options: {
  activeView: ReturnType<typeof ref<string>>,
  activeComponent: ReturnType<typeof ref<Component | null>>
}) {
  const { activeView, activeComponent } = options
  
  // Initialiser les breadcrumbs
  const breadcrumbItems = ref<NavItem[]>([
    {
      id: 'home',
      label: 'Accueil',
      path: '#home'
    }
  ])
  
  // Configuration des groupes de navigation
  const navigationGroups = [
    {
      id: 'cv',
      title: 'Curriculum Vitae',
      items: [
        { id: 'basics', label: 'Informations de base', path: '#basics' },
        { id: 'experience', label: 'Exp√©rience', path: '#experience' },
        // Autres items...
      ]
    }
  ]
  
  // G√©rer la navigation vers une nouvelle vue
  const handleNavigation = async (path: string) => {
    // Extraire l'ID de vue du chemin
    const viewId = path.startsWith('#') ? path.substring(1) : path
    
    // Gestion des cas de mapping d'ID
    activeView.value = viewId === 'experience' ? 'work' : viewId
    
    // Mettre √† jour les breadcrumbs et charger les donn√©es
    updateBreadcrumbs(viewId)
    await loadDataForView(viewId)
  }
  
  // Fonction pour mettre √† jour les breadcrumbs
  const updateBreadcrumbs = (viewId: string) => {
    // Rechercher l'item de navigation correspondant
    // et mettre √† jour les breadcrumbs...
  }
  
  // Fonction pour charger les donn√©es
  const loadDataForView = async (viewId: string) => {
    // Charger les donn√©es en fonction de l'ID de vue...
  }
  
  return {
    navigationGroups,
    breadcrumbItems,
    handleNavigation,
    updateBreadcrumbs
  }
}

// Utilisation dans App.vue
<script setup>
import { ref } from 'vue'
import { useNavigation } from '@/composables/useNavigation'

const activeView = ref('basics')
const activeComponent = ref(null)

const { 
  navigationGroups, 
  breadcrumbItems, 
  handleNavigation 
} = useNavigation({ activeView, activeComponent })
</script>

<template>
  <!-- Important: inclure des conditions pour TOUS les √©tats possibles -->
  <div v-if="activeView === 'experience'" class="bg-neutral-850 rounded-md">
    <WorkList />
  </div>
  
  <!-- Inclure √©galement une condition pour 'work' √† cause du mapping -->
  <div v-if="activeView === 'work'" class="bg-neutral-850 rounded-md">
    <WorkList />
  </div>
</template>
</example>

<example>
// Bon exemple: Test unitaire pour un composable de navigation
// useNavigation.spec.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { useNavigation } from '../ui/useNavigation'
import { ref, type Component } from 'vue'

// D√©finir des mocks pour les stores
const mockResumeStore = {
  loadResume: vi.fn(),
  resume: { basics: { name: 'Test Name' } }
}

// Mocker tous les stores sans utiliser vi.mock au niveau sup√©rieur
vi.mock('@ui/modules/cv/presentation/stores/resume', () => ({
  useResumeStore: () => mockResumeStore
}))

// Cr√©er une fonction utilitaire pour les mocks
const createMockStore = (name: string) => ({
  [`load${name}s`]: vi.fn()
})

describe('useNavigation', () => {
  // Configurer l'√©tat initial pour chaque test
  const activeView = ref('basics')
  const activeComponent = ref<Component | null>(null)
  
  let navigation: ReturnType<typeof useNavigation>
  
  beforeEach(() => {
    // R√©initialiser l'√©tat avant chaque test
    activeView.value = 'basics'
    navigation = useNavigation({ activeView, activeComponent })
  })
  
  it('should provide the complete navigation structure', () => {
    // V√©rifier que la structure de navigation est compl√®te
    expect(navigation.navigationGroups.length).toBe(2)
    
    const cvGroup = navigation.navigationGroups[0]
    expect(cvGroup.id).toBe('cv')
    expect(cvGroup.items.length).toBe(12)
  })
  
  it('should handle navigation to different sections', async () => {
    // Tester la navigation vers diff√©rentes sections
    await navigation.handleNavigation('#experience')
    
    // V√©rifier le mapping de 'experience' vers 'work'
    expect(activeView.value).toBe('work')
    
    // Tester un autre cas sans mapping
    await navigation.handleNavigation('#education')
    expect(activeView.value).toBe('education')
  })
  
  it('should update breadcrumbs correctly', async () => {
    // Tester la mise √† jour des miettes de pain
    await navigation.handleNavigation('#education')
    
    expect(navigation.breadcrumbItems.value.length).toBe(2)
    expect(navigation.breadcrumbItems.value[1].id).toBe('education')
    expect(navigation.breadcrumbItems.value[1].label).toBe('Formation')
  })
})
</example>

<example type="invalid">
// Mauvais exemple: Logique m√©tier int√©gr√©e dans le composant
<script setup>
import { ref, computed, onMounted } from 'vue'
import { resumeSchema } from '@/core/schemas/resume.schema'
import { z } from 'zod'

// Cette logique de validation devrait √™tre extraite dans un composable
const resumeData = ref({})
const validationErrors = ref([])

function validateResume() {
  try {
    resumeSchema.parse(resumeData.value)
    validationErrors.value = []
    return true
  } catch (error) {
    if (error instanceof z.ZodError) {
      validationErrors.value = error.errors.map(err => ({
        path: err.path.join('.'),
        message: err.message
      }))
      return false
    }
    throw error
  }
}

// Cette logique de stockage local devrait √™tre extraite dans un composable
onMounted(() => {
  try {
    const stored = localStorage.getItem('resume')
    if (stored) {
      resumeData.value = JSON.parse(stored)
    }
  } catch (error) {
    console.error('Failed to load resume from localStorage', error)
  }
})

function saveResume() {
  if (validateResume()) {
    try {
      localStorage.setItem('resume', JSON.stringify(resumeData.value))
    } catch (error) {
      console.error('Failed to save resume to localStorage', error)
    }
  }
}

// Le composant devient trop complexe avec toute cette logique
</script>
</example>

<example type="invalid">
// Mauvais exemple: Navigation incoh√©rente entre composable et template
// useNavigation.ts
export function useNavigation(options) {
  const { activeView } = options
  
  const handleNavigation = (path) => {
    const viewId = path.startsWith('#') ? path.substring(1) : path
    
    // Transformation de 'experience' en 'work' dans le composable
    activeView.value = viewId === 'experience' ? 'work' : viewId
  }
  
  return { handleNavigation }
}

// App.vue
<template>
  <!-- Incoh√©rent: v√©rifie seulement 'experience' mais pas 'work' -->
  <div v-if="activeView === 'experience'">
    <WorkList />
  </div>
  
  <!-- Manque la condition pour 'work' alors que le composable
       transforme 'experience' en 'work' -->
  
  <!-- Cela provoquera un probl√®me quand on clique sur "Exp√©rience professionnelle" -->
</template>
</example>

<example type="invalid">
// Mauvais exemple: Test incomplet pour un composable de navigation
// useNavigation.spec.ts
import { describe, it, expect } from 'vitest'
import { useNavigation } from '../useNavigation'
import { ref } from 'vue'

describe('useNavigation', () => {
  it('should handle navigation', () => {
    const activeView = ref('basics')
    const { handleNavigation } = useNavigation({ activeView })
    
    // Test incomplet: ne v√©rifie pas le mapping 'experience' -> 'work'
    handleNavigation('#basics')
    expect(activeView.value).toBe('basics')
    
    // Manque de test pour les autres cas comme 'experience' -> 'work'
    
    // Ne teste pas les mises √† jour de breadcrumbs
    
    // Ne teste pas les erreurs ou cas limites
  })
})
</example>

## ‚ö†Ô∏è Points Critiques

<critical>
- NE PAS extraire de logique dans un composable si cela n'apporte pas une r√©elle valeur de r√©utilisation ou de clart√©
- √âVITER de cr√©er des composables "fourre-tout" qui violent le principe de responsabilit√© unique
- RESPECTER la contrainte de performance du projet (<500ms) dans la conception des composables
- PR√âF√âRER plusieurs composables simples √† un composable complexe
- DOCUMENTER clairement l'interface des composables pour faciliter leur utilisation
- NE PAS cr√©er de composables pour une logique purement statique qui ne g√®re pas d'√©tat au fil du temps
- TOUJOURS assurer la coh√©rence entre les transformations d'√©tat dans les composables et les conditions d'affichage dans les templates
- TOUJOURS tester tous les cas de mapping et transformations dans les composables (par ex: 'experience' ‚Üí 'work')
</critical>

## ‚úÖ Bonnes Pratiques

- **Localisation**: Placer les composables dans un dossier d√©di√© (`/composables`) organis√© par domaine
- **Testabilit√©**: Concevoir les composables pour qu'ils soient facilement testables en isolation
- **S√©paration des pr√©occupations**: Suivre les principes de Clean Architecture
  - Composables de domaine (logique m√©tier pure)
  - Composables d'application (cas d'utilisation)
  - Composables d'infrastructure (localStorage, API, etc.)
  - Composables UI (navigation, forms, etc.)
- **Interfaces claires**: Retourner uniquement ce qui est n√©cessaire au composant consommateur
- **Documentation**: Documenter les param√®tres et valeurs de retour avec JSDoc
- **R√©activit√©**: Utiliser `toValue()` pour supporter les refs et les getters comme arguments
- **Effet de bord**: Nettoyer correctement les effets de bord avec `onUnmounted`
- **√âtat isol√©**: Chaque instance d'un composable doit avoir son propre √©tat isol√©
- **Composition**: Construire des composables complexes en composant des composables plus simples
- **Coh√©rence UI**: S'assurer que les transformations d'√©tat dans les composables sont refl√©t√©es correctement dans les templates
- **Tests TDD**: √âcrire d'abord les tests qui d√©finissent le comportement attendu du composable

## üîÑ Organisation par Couche Architecturale

Selon les principes Clean Architecture du projet, les composables doivent √™tre organis√©s par couche:

1. **Composables de domaine** (`/composables/domain`)
   - Logique m√©tier pure li√©e aux entit√©s du domaine
   - Validation selon le sch√©ma JSON Resume
   - Transformation et enrichissement des donn√©es
   
2. **Composables d'application** (`/composables/application`)
   - Cas d'utilisation qui orchestrent les op√©rations
   - Workflow m√©tier
   - Gestion de l'√©tat applicatif
   
3. **Composables d'infrastructure** (`/composables/infrastructure`)
   - Interaction avec localStorage
   - Appels API
   - Export PDF/HTML/JSON
   
4. **Composables UI** (`/composables/ui`)
   - Gestion des interactions utilisateur
   - Gestion des formulaires et de la navigation
   - Animation et transitions

## üß™ Workflow TDD pour les Composables

1. **D√©finir l'interface**
   - Identifier les inputs (param√®tres) et outputs (valeurs retourn√©es)
   - D√©finir les d√©pendances et services requis

2. **√âcrire les tests unitaires**
   - Tester l'initialisation de l'√©tat
   - Tester les transformations et r√©actions aux inputs
   - Tester les cas limites et les erreurs
   - Mocker toutes les d√©pendances externes

3. **Impl√©menter le composable**
   - √âcrire l'impl√©mentation minimale pour faire passer les tests
   - Observer le principe YAGNI (You Aren't Gonna Need It)
   - Refactoriser pour am√©liorer la lisibilit√© et la performance

4. **Tests d'int√©gration**
   - V√©rifier l'interaction avec les autres composables
   - Tester le comportement dans des composants r√©els

5. **Documentation et exemples**
   - Documenter l'API avec JSDoc
   - Fournir des exemples d'utilisation

## üîó R√©f√©rences
- [Vue.js - Composables](mdc:https:/vuejs.org/guide/reusability/composables.html)
- [Conventions et Bonnes Pratiques](mdc:https:/vuejs.org/guide/reusability/composables.html#conventions-and-best-practices)
- [Clean Code dans Vue.js](mdc:https:/dev.to/hakimov_dev/writing-clean-reusable-components-in-vue-3-composition-api-best-practices-37mj)
- [VueUse](mdc:https:/vueuse.org) - Collection de composables Vue
- [Vitest](mdc:https:/vitest.dev) - Framework de test unitaire pour Vue

<version>1.1.0</version> 