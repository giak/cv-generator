---
description: ENFORCE Test-Driven Development workflow with Vitest in Vue 3 components to ensure robust and maintainable code
globs: src/**/*.{spec,test}.{ts,tsx}
---
# Test-Driven Development Workflow with Vitest

---
description: ENFORCE Test-Driven Development workflow with Vitest in Vue 3 components to ensure robust and maintainable code
globs: ["packages/**/*.{spec,test}.{ts,tsx}", "packages/**/__tests__/*.{ts,tsx}"]
tags: [testing, vitest, vue3, tdd, ddd, composables, components]
priority: 1
version: 3.0.0
---

## Context
- Applied when developing new features or fixing bugs
- Ensures code quality through test-first approach
- Enforces clean and maintainable code
- Maintains high test coverage
- Follows DDD, Vue 3, Pinia, and Vitest best practices
- Supports monorepo architecture with multiple packages
- Provides reusable test patterns and snippets

## Test Environment Setup

### Base Vitest Configuration (vitest.shared.ts)
```typescript
import { defineConfig, mergeConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

const baseConfig = defineConfig({
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./vitest.setup.ts'],
    coverage: {
      provider: 'istanbul',
      reporter: ['text', 'json', 'html', 'lcov'],
      all: true,
      include: ['src/**/*.{vue,ts}'],
      exclude: [
        'src/**/*.d.ts',
        'src/**/*.test.ts',
        'src/**/*.spec.ts',
        'src/main.ts',
        'src/types/**/*'
      ]
    },
    reporters: ['default', 'html'],
    include: [
      'src/**/*.{test,spec}.{js,ts}',
      'src/**/__tests__/*.{js,ts}'
    ],
    exclude: ['e2e/**/*', 'node_modules/**/*'],
    pool: 'vmThreads',
    maxThreads: 4,
    minThreads: 1
  }
})

export const createPackageConfig = (packagePath: string) => {
  return mergeConfig(baseConfig, {
    plugins: [vue()],
    resolve: {
      alias: {
        '@': resolve(packagePath, './src'),
        '@tests': resolve(packagePath, './tests'),
        '@shared': resolve(packagePath, './src/shared'),
        '@components': resolve(packagePath, './src/components'),
        '@composables': resolve(packagePath, './src/composables'),
        '@stores': resolve(packagePath, './src/stores')
      }
    }
  })
}

### Setup File (vitest.setup.ts)
```typescript
import { expect, vi, beforeAll, afterAll } from 'vitest'
import { cleanup } from '@testing-library/vue'
import matchers from '@testing-library/jest-dom/matchers'
import { setActivePinia, createPinia } from 'pinia'
import { config } from '@vue/test-utils'

// Extend matchers
expect.extend(matchers)

// Global test setup
beforeAll(() => {
  // Mock ResizeObserver
  global.ResizeObserver = vi.fn().mockImplementation(() => ({
    observe: vi.fn(),
    unobserve: vi.fn(),
    disconnect: vi.fn(),
  }))

  // Mock IntersectionObserver
  global.IntersectionObserver = vi.fn().mockImplementation(() => ({
    observe: vi.fn(),
    unobserve: vi.fn(),
    disconnect: vi.fn(),
  }))
})

// Global test cleanup
afterAll(() => {
  cleanup()
})

// Configure Vue Test Utils
config.global.stubs = {
  transition: false,
  'router-link': true
}
```

## Test Patterns Library

### 1. Composable Test Pattern
```typescript
// useFeature.spec.ts
import { renderComposable } from '@tests/utils'
import { useFeature } from './useFeature'
import { describe, it, expect, beforeEach } from 'vitest'

describe('useFeature', () => {
  const { result } = renderComposable(() => useFeature())
  
  beforeEach(() => {
    // Reset state if needed
  })

  it('should initialize with default state', () => {
    expect(result.value).toBeDefined()
  })

  it('should handle async operations', async () => {
    await result.execute()
    expect(result.data).toBeDefined()
  })

  it('should handle errors gracefully', async () => {
    // Test error scenarios
  })
})
```

### 2. Component Test Pattern
```typescript
// Feature.spec.ts
import { render, screen, fireEvent } from '@testing-library/vue'
import { createTestingPinia } from '@pinia/testing'
import Feature from './Feature.vue'

describe('Feature.vue', () => {
  const renderComponent = (props = {}) => {
    return render(Feature, {
      props,
      global: {
        plugins: [
          createTestingPinia({
            createSpy: vi.fn
          })
        ]
      }
    })
  }

  it('should render correctly', () => {
    const { container } = renderComponent()
    expect(container).toMatchSnapshot()
  })

  it('should handle user interactions', async () => {
    renderComponent()
    await fireEvent.click(screen.getByRole('button'))
    expect(screen.getByText('Updated')).toBeInTheDocument()
  })
})
```

### 3. Store Test Pattern
```typescript
// featureStore.spec.ts
import { setActivePinia, createPinia } from 'pinia'
import { useFeatureStore } from './featureStore'
import { describe, it, expect, beforeEach } from 'vitest'

describe('Feature Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  it('should manage state correctly', () => {
    const store = useFeatureStore()
    expect(store.items).toEqual([])
    store.addItem({ id: 1 })
    expect(store.items).toHaveLength(1)
  })

  it('should handle async actions', async () => {
    const store = useFeatureStore()
    await store.fetchItems()
    expect(store.isLoading).toBe(false)
  })
})
```

### 4. API Test Pattern
```typescript
// api.spec.ts
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { api } from './api'

describe('API Client', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('should handle successful requests', async () => {
    const mockData = { id: 1 }
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: () => Promise.resolve(mockData)
    })

    const result = await api.get('/endpoint')
    expect(result).toEqual(mockData)
  })

  it('should handle errors', async () => {
    global.fetch = vi.fn().mockRejectedValue(new Error('Network error'))
    await expect(api.get('/endpoint')).rejects.toThrow('Network error')
  })
})
```

### 5. Form Test Pattern
```typescript
// Form.spec.ts
import { render, screen, fireEvent } from '@testing-library/vue'
import { Form } from './Form.vue'

describe('Form.vue', () => {
  const submitHandler = vi.fn()

  const renderForm = (props = {}) => {
    return render(Form, {
      props: {
        onSubmit: submitHandler,
        ...props
      }
    })
  }

  it('should validate form inputs', async () => {
    renderForm()
    
    await fireEvent.update(
      screen.getByLabelText('Email'),
      'invalid-email'
    )
    
    await fireEvent.submit(screen.getByRole('form'))
    
    expect(screen.getByText('Invalid email')).toBeInTheDocument()
    expect(submitHandler).not.toHaveBeenCalled()
  })

  it('should submit valid form data', async () => {
    renderForm()
    
    await fireEvent.update(
      screen.getByLabelText('Email'),
      'test@example.com'
    )
    
    await fireEvent.submit(screen.getByRole('form'))
    
    expect(submitHandler).toHaveBeenCalledWith({
      email: 'test@example.com'
    })
  })
})
```

## Testing Standards

### Code Coverage Requirements
<critical>
- NEVER commit code without tests
- NEVER skip unit tests for business logic
- NEVER write tests after implementation
- ALWAYS follow DDD layer testing patterns
- ALWAYS maintain minimum coverage:
  - Domain Layer: 100%
  - Application Layer: 100%
  - Infrastructure Layer: > 90%
  - UI Layer: > 90%
  - Composables: 100%
</critical>

### Test Organization
- Follow AAA pattern (Arrange-Act-Assert)
- Group related tests with describe blocks
- Clear test descriptions
- Proper test isolation
- Mock external dependencies
- Use beforeEach for common setup
- Clear mocks between tests
- Respect DDD layer boundaries in tests
- Separate unit, integration, and e2e tests
- Use test utilities for common operations

### Test Utilities
```typescript
// @tests/utils/index.ts
import { ref } from 'vue'
import { flushPromises } from '@vue/test-utils'

export const renderComposable = <T>(composable: () => T) => {
  const result = ref<T>()
  result.value = composable()
  return { result }
}

export const waitForNextTick = async () => {
  await new Promise(resolve => setTimeout(resolve, 0))
}

export const waitForAnimation = async () => {
  await new Promise(resolve => setTimeout(resolve, 300))
}

export const mockApiResponse = (data: any) => {
  return {
    ok: true,
    json: () => Promise.resolve(data)
  }
}

export const mockApiError = (status = 400, message = 'Error') => {
  return {
    ok: false,
    status,
    json: () => Promise.resolve({ message })
  }
}
```

## Best Practices
- Write tests before implementation
- Keep tests simple and focused
- Use meaningful test descriptions
- Maintain test isolation
- Mock external dependencies
- Follow the AAA pattern
- Use TypeScript for type safety
- Regular test maintenance
- Use expect.objectContaining for partial object matching
- Use vi.mock for dependency mocking
- Use createPinia and setActivePinia for store testing
- Clear mocks between tests with vi.clearAllMocks()
- Use proper type imports
- Separate type and value imports
- Respect DDD layer boundaries
- Test error cases thoroughly
- Use data-testid for test selectors
- Avoid testing implementation details
- Test component contracts and behaviors
- Use snapshots sparingly
- Mock time-based operations
- Test accessibility requirements

## Performance Standards
- Domain Layer tests: < 50ms per test
- Application Layer tests: < 100ms per test
- Infrastructure Layer tests: < 200ms per test
- UI Layer tests: < 500ms per test
- Full suite: < 2min
- Watch mode for development
- Parallel test execution
- Efficient test setup and teardown
- Minimal use of beforeAll/afterAll
- Smart use of test.concurrent for parallel tests

## Continuous Integration
- Run tests before commit
- Maintain coverage thresholds
- Regular test maintenance
- Update tests when requirements change
- Test all DDD layers independently
- Automated test runs on PR
- Performance monitoring
- Test result reporting
- Coverage reporting
- Test timing analysis