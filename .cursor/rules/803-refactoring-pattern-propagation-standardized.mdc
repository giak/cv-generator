---
description: "APPLIQUER lors du REFACTORING apr√®s impl√©mentation partielle d'un pattern pour GARANTIR coh√©rence architecturale"
globs: "src/**/*.{js,ts,jsx,tsx,vue}"
---
---
title: "Pattern Propagation Post-Story"
version: "1.0.0"
description: "APPLIQUER lors du REFACTORING apr√®s impl√©mentation partielle d'un pattern pour GARANTIR coh√©rence architecturale"
globs: "src/**/*.{js,ts,jsx,tsx,vue}"
alwaysApply: false
priority: 45
compatibility: ">=0.45"
lastUpdated: "2025-03-10"
tags: ["refactoring", "pattern", "architecture", "technical-debt", "clean-architecture"]
---

# ‚ôªÔ∏è Propagation Syst√©matique de Pattern Post-Story

## üìã Vue d'Ensemble
Cette r√®gle d√©finit le processus syst√©matique pour propager un pattern nouvellement impl√©ment√© dans une story (comme un pattern Result/Option) √† travers l'ensemble de l'application, garantissant ainsi la coh√©rence architecturale et √©vitant la coexistence de plusieurs approches concurrentes.

> ‚ö†Ô∏è **Attention**: Cette r√®gle s'applique apr√®s qu'une story a impl√©ment√© avec succ√®s un pattern architectural, mais n'a couvert qu'une partie des cas d'utilisation vis√©s. Elle √©vite l'accumulation de dette technique li√©e √† des impl√©mentations partielles.

## üéØ Objectifs
- Garantir une architecture coh√©rente √† travers l'application
- R√©duire la dette technique li√©e aux impl√©mentations partielles
- Faciliter la maintenance √† long terme du codebase
- √âviter la confusion caus√©e par la coexistence de plusieurs approches
- Capitaliser sur l'investissement initial dans le pattern

## ‚úÖ Requirements

- Identifier les zones d'application restantes en consultant:
  - L'historique de discussion du chat
  - Les commits r√©cents (git diff)
  - La documentation d'architecture
  - Les tests existants
- Cr√©er une branche d√©di√©e au refactoring
- Impl√©menter le pattern de fa√ßon coh√©rente avec les exemples d√©j√† r√©alis√©s
- Assurer la couverture de test pour chaque composant refactoris√©
- Documenter l'avancement du refactoring
- √âviter les abstractions inutiles (pas de barrel exports, pas d'adaptateurs superflus)
- Maintenir la compatibilit√© avec le code existant pendant la transition

## üìù Processus de Refactoring

### 1Ô∏è‚É£ Pr√©paration
1. **Identifier le pattern √† propager**:
   - √âtudier les impl√©mentations existantes (r√©alis√©es dans la story)
   - Comprendre les principes architecturaux appliqu√©s
   - Noter les particularit√©s de l'impl√©mentation actuelle

2. **Cataloguer les cibles de refactoring**:
   - Lister les components/modules similaires qui devraient appliquer ce pattern
   - Identifier les d√©pendances qui pourraient √™tre affect√©es
   - Prioriser selon l'impact et la fr√©quence d'utilisation

3. **Cr√©er un plan de migration**:
   - Documenter les exemples existants comme r√©f√©rences
   - √âtablir un journal pour suivre la progression
   - D√©finir des crit√®res de r√©ussite pour chaque √©l√©ment

### 2Ô∏è‚É£ Impl√©mentation
1. **Proc√©der par composant logique**:
   - Refactoriser un composant ou module √† la fois
   - Suivre strictement les patterns √©tablis dans la story initiale
   - Maintenir la m√™me architecture de validation/erreur

2. **Transformer progressivement**:
   - √âcrire de nouveaux tests pour le comportement attendu
   - Impl√©menter la nouvelle version avec le pattern
   - V√©rifier la compatibilit√© avec les utilisations existantes
   - Mettre √† jour les importations dans les fichiers consommateurs

3. **Valider chaque √©tape**:
   - Ex√©cuter la suite de tests compl√®te
   - V√©rifier la coh√©rence du pattern appliqu√©
   - Documenter les difficult√©s rencontr√©es pour r√©f√©rence future

### 3Ô∏è‚É£ Finalisation
1. **V√©rification globale**:
   - Revue compl√®te du code refactoris√©
   - Contr√¥le de la couverture de test
   - Ex√©cution de tous les tests de l'application

2. **Documentation**:
   - Mettre √† jour la documentation d'architecture
   - Ajouter des commentaires explicatifs si n√©cessaire
   - Compl√©ter le journal du refactoring

3. **D√©ploiement**:
   - Soumettre pour revue de code
   - Int√©grer dans la branche principale
   - Surveiller les impacts potentiels apr√®s d√©ploiement

## üí° Exemples

<example>
// Value Object original impl√©ment√© lors de la story initiale
// src/core/cv/domain/value-objects/email.value-object.ts

export class Email {
  private constructor(private readonly value: string) {}

  public static create(email: string): ResultType<Email> {
    if (!email || email.trim() === '') {
      return createFailure([{
        code: ERROR_CODES.RESUME.BASICS.MISSING_EMAIL,
        message: "L'adresse email est requise",
        field: "email",
        severity: "error",
        layer: ValidationLayerType.DOMAIN
      }]);
    }

    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return createFailure([{
        code: ERROR_CODES.RESUME.BASICS.INVALID_EMAIL,
        message: "Format d'email invalide",
        field: "email",
        severity: "error",
        layer: ValidationLayerType.DOMAIN,
        suggestion: "V√©rifiez que votre email contient un @ et un domaine valide"
      }]);
    }

    return createSuccess(new Email(email));
  }

  public getValue(): string {
    return this.value;
  }
}

// Nouveau Value Object √† impl√©menter en suivant le m√™me pattern
// src/core/cv/domain/value-objects/url.value-object.ts

export class Url {
  private constructor(private readonly value: string) {}

  public static create(url: string): ResultType<Url> {
    if (!url || url.trim() === '') {
      return createFailure([{
        code: ERROR_CODES.COMMON.REQUIRED_FIELD,
        message: "L'URL est requise",
        field: "url",
        severity: "error",
        layer: ValidationLayerType.DOMAIN
      }]);
    }

    try {
      // V√©rifier si l'URL est valide
      new URL(url);
      
      // V√©rifier le protocole
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        return createFailure([{
          code: ERROR_CODES.RESUME.PROJECT.INVALID_URL,
          message: "Format d'URL invalide",
          field: "url",
          severity: "warning",
          layer: ValidationLayerType.DOMAIN,
          suggestion: "L'URL doit commencer par http:// ou https://"
        }]);
      }

      return createSuccess(new Url(url));
    } catch (error) {
      return createFailure([{
        code: ERROR_CODES.RESUME.PROJECT.INVALID_URL,
        message: "Format d'URL invalide",
        field: "url",
        severity: "error",
        layer: ValidationLayerType.DOMAIN,
        suggestion: "V√©rifiez que l'URL est correctement format√©e"
      }]);
    }
  }

  public getValue(): string {
    return this.value;
  }
}
</example>

<example type="invalid">
// Propagation inconsistante du pattern - √Ä √âVITER

// M√©lange d'approches: certains modules utilisent Result pattern
export class Email {
  private constructor(private readonly value: string) {}

  public static create(email: string): ResultType<Email> {
    // Pattern bien impl√©ment√© avec Result
    // ...code omis...
  }
}

// Tandis que d'autres continuent d'utiliser les anciennes approches
export class Url {
  constructor(private readonly value: string) {}

  public static create(url: string): Url | null {
    if (!url || !url.startsWith('http')) {
      console.error('URL invalide');
      return null;
    }
    return new Url(url);
  }
  
  // Utilisations incoh√©rentes du getter
  public getUrlValue() {
    return this.value;
  }
}

// La coexistence de diff√©rentes approches complique l'usage
async function saveProject(data) {
  // Utilisation inconsistante des validations
  const emailResult = Email.create(data.email);
  if (!emailResult.success) {
    return handleValidationErrors(emailResult.error);
  }

  // Approche diff√©rente pour URL
  const url = Url.create(data.url);
  if (!url) {
    return handleError('URL invalide');
  }
  
  // Code compliqu√© par les diff√©rentes approches de validation
}
</example>

## ‚ö†Ô∏è Points Critiques

<critical>
- TOUJOURS respecter strictement le pattern √©tabli par la story initiale
- JAMAIS m√©langer l'ancien et le nouveau pattern dans un m√™me module
- UTILISER les m√™mes noms de m√©thodes et conventions dans tous les composants refactoris√©s
- MAINTENIR une couverture de test similaire ou sup√©rieure √† celle des composants initiaux
- R√âF√âRENCER explicitement les impl√©mentations existantes comme mod√®les
- √âVITER d'introduire des abstractions suppl√©mentaires non pr√©sentes dans l'impl√©mentation initiale
</critical>

## ‚úÖ Bonnes Pratiques

- **Syst√©matique**: Traiter un type de composant √† la fois (tous les Value Objects, puis tous les Services, etc.)
- **Incr√©mental**: Proc√©der par petits changements testables plut√¥t que des refactorings massifs
- **Tra√ßabilit√©**: Maintenir un journal documentant l'avancement du refactoring
- **Compatibilit√©**: Assurer que le code existant continue de fonctionner pendant la transition
- **Test-First**: √âcrire ou adapter les tests avant d'impl√©menter le refactoring
- **Revue**: Faire r√©viser r√©guli√®rement le code refactoris√© pour garantir la coh√©rence

## üîÑ Progression du Refactoring

Pour maintenir un suivi clair de l'avancement, cr√©ez un fichier README ou CHANGELOG d√©di√© contenant:

```markdown
# Journal de Refactoring - Pattern Result/Option

## Impl√©mentations Compl√©t√©es

### Value Objects
- [x] Email (story initiale)
- [x] WorkDate (story initiale)
- [x] Phone (story initiale)
- [ ] DateRange
- [ ] Url
- [ ] ...

### Services
- [x] ValidationService (story initiale)
- [ ] WorkValidationService
- [ ] SkillValidationService
- [ ] ...

### Composants UI
- [ ] BasicsForm
- [ ] WorkForm
- [ ] ...

## Notes et D√©cisions
- Format des messages d'erreur standardis√© avec code, message, field, severity
- Approche de compatibilit√©: m√©thodes de conversion pour code existant
- Validation √† appliquer dans la couche domaine avant tout
```

## üîÑ Int√©gration avec le Workflow Agile

Cette r√®gle s'int√®gre naturellement dans le workflow agile d√©fini par `801-workflow-agile-standardized`, notamment:

1. **Suite √† l'approbation d'une story**: Lorsqu'une story impl√©mentant un nouveau pattern est marqu√©e comme compl√©t√©e
2. **Planification du refactoring**: Cr√©er une story d√©di√©e au refactoring ou des t√¢ches techniques dans les sprints suivants
3. **Priorisation**: √Ä √©valuer selon l'impact de la fragmentation architecturale sur la dette technique

<requires>801-workflow-agile-standardized</requires>
<requires>802-code-generation-standardized</requires>

## üîó R√©f√©rences
- [Clean Architecture - Uncle Bob](mdc:https:/blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Working Effectively with Legacy Code - Michael Feathers](mdc:https:/www.oreilly.com/library/view/working-effectively-with/0131177052)
- [Refactoring Patterns - Martin Fowler](mdc:https:/refactoring.com/catalog)
- [The Strangler Fig Pattern - Martin Fowler](mdc:https:/martinfowler.com/bliki/StranglerFigApplication.html)

<version>1.0.0</version> 