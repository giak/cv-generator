---
description: "DEFINE core project architecture, technical stack, and development principles for the CV Generator application"
globs: ["packages/**/*"]
alwaysApply: false
---
---
title: "CV Generator - Project Architecture & Technical Standards"
version: "2.3.0"
description: "DEFINE core project architecture, technical stack, and development principles for the CV Generator application"
globs: ["packages/**/*"]
lastUpdated: "2024-07-01"
tags: ["architecture", "standards", "monorepo", "ddd", "solid"]
---

# CV Generator - Project Architecture & Technical Standards

## Context
- This rule defines the architectural principles, technical stack, and development standards for the CV Generator application
- It serves as the central reference for understanding code organization and project structure
- All development work should align with these architectural decisions and coding standards
- This document references other critical standards including [naming conventions](mdc:.cursor/rules/002-naming-conventions.mdc) and [code generation standards](mdc:.cursor/rules/802-code-generation-standardized.mdc)

## Requirements
- The application MUST follow Clean Architecture principles with clear separation of concerns
- The codebase MUST be organized as a monorepo with well-defined package boundaries
- Domain logic MUST be implemented following Domain-Driven Design patterns
- All code MUST adhere to the SOLID principles and TypeScript standards defined in this document
- Validation MUST follow the multi-layer strategy described in this document
- All code MUST conform to the project's [naming conventions](mdc:.cursor/rules/002-naming-conventions.mdc)
- Code generation and modification MUST follow the [code generation standards](mdc:.cursor/rules/802-code-generation-standardized.mdc)

## Project Identity

The CV Generator is a modern web application for creating and managing resumes using the JSON Resume format. The architecture follows Clean Architecture and Domain-Driven Design principles to ensure clear separation of responsibilities, easy maintenance, and flexible system evolution.

## Technical Stack

| Technology   | Version | Description                             | Status      |
| ------------ | ------- | --------------------------------------- | ----------- |
| TypeScript   | 5.7+    | Primary language with strict typing     | âœ… In use   |
| Vue.js       | 3.4+    | UI framework with Composition API       | âœ… In use   |
| Vite         | 6.0+    | Build tool and dev server               | âœ… In use   |
| Pinia        | 2.1+    | State management                        | âœ… In use   |
| Tailwind CSS | 3.x     | Utility-first CSS framework             | âœ… In use   |
| Zod          | 3.22+   | Schema validation and runtime typing    | âœ… In use   |
| Vitest       | 3.0+    | Testing framework                       | âœ… In use   |
| Playwright   | Latest  | End-to-end testing                      | ğŸš§ Planned  |
| pnpm         | 10+     | Package manager with workspace support  | âœ… In use   |
| Biome        | 1.9+    | Linting and formatting                  | âœ… In use   |

## Key Architectural Decisions

### 1. Clean Architecture

- ğŸ”„ Strict separation of layers (UI, Application, Domain, Infrastructure)
- ğŸ”„ Dependencies pointing inward
- ğŸ”„ Dependency inversion for repositories and services

### 2. Domain-Driven Design

- ğŸ“¦ Organization by bounded contexts (CV, Export, User)
- ğŸ’ Rich entities with encapsulated business logic
- ğŸ’  Value Objects for complex types (Email, Phone)
- ğŸ“‹ Aggregates for maintaining consistency (Resume)
- ğŸ”Œ Explicit port interfaces in each bounded context

### 3. Monorepo Structure

- ğŸ“‚ Independent packages with clear responsibilities
- ğŸ”„ Shared utilities for reuse
- ğŸ§ª Co-located tests with implementation code

### 4. Validation Strategy

- âœ… Schema validation with Zod
- ğŸ”„ Specialized composables for form validation
- ğŸ“ Real-time validation with user feedback
- ğŸ”€ Separation between UI validation and domain validation

## Project Structure

```
/
â”œâ”€â”€ packages/                    # Monorepo workspace
â”‚   â”œâ”€â”€ core/                    # Domain & Application layers
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ cv/              # CV Bounded Context
â”‚   â”‚       â”‚   â”œâ”€â”€ domain/      # Domain layer
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ entities/   # Domain entities
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ value-objects/ # Value Objects
â”‚   â”‚       â”‚   â”œâ”€â”€ application/ # Application layer
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ use-cases/  # Business use cases
â”‚   â”‚       â”‚   â””â”€â”€ ports/       # Interface ports
â”‚   â”‚       â”‚       â””â”€â”€ repositories/ # Repository interfaces
â”‚   â”‚       â”œâ”€â”€ export/          # Export Bounded Context
â”‚   â”‚       â”‚   â”œâ”€â”€ domain/      # Domain entities and logic
â”‚   â”‚       â”‚   â”œâ”€â”€ application/ # Application services
â”‚   â”‚       â”‚   â””â”€â”€ ports/       # Interface ports
â”‚   â”‚       â”œâ”€â”€ user/            # User Bounded Context
â”‚   â”‚       â”‚   â”œâ”€â”€ domain/      # User domain model
â”‚   â”‚       â”‚   â”œâ”€â”€ application/ # User application services
â”‚   â”‚       â”‚   â””â”€â”€ ports/       # User interfaces
â”‚   â”‚       â”œâ”€â”€ shared/          # Shared domain elements
â”‚   â”‚       â”‚   â”œâ”€â”€ domain/      # Shared domain concepts
â”‚   â”‚       â”‚   â””â”€â”€ application/ # Shared application logic
â”‚   â”‚       â””â”€â”€ modules/         # Legacy/alternative organization
â”‚   â”‚
â”‚   â”œâ”€â”€ ui/                      # Presentation layer
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ components/      # Vue components
â”‚   â”‚       â”‚   â””â”€â”€ shared/      # Shared components
â”‚   â”‚       â”œâ”€â”€ modules/         # Feature modules
â”‚   â”‚       â”‚   â””â”€â”€ cv/          # CV module
â”‚   â”‚       â”‚       â”œâ”€â”€ presentation/ # Presentation components
â”‚   â”‚       â”‚       â””â”€â”€ stores/  # State management
â”‚   â”‚       â”œâ”€â”€ App/             # Application root
â”‚   â”‚       â”œâ”€â”€ plugins/         # Vue plugins
â”‚   â”‚       â”œâ”€â”€ assets/          # Static assets
â”‚   â”‚       â””â”€â”€ core/            # Core UI logic
â”‚   â”‚
â”‚   â”œâ”€â”€ infrastructure/          # Infrastructure layer
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ repositories/    # Data persistence implementations
â”‚   â”‚       â”œâ”€â”€ services/        # External service implementations
â”‚   â”‚       â””â”€â”€ errors/          # Infrastructure-specific errors
â”‚   â”‚
â”‚   â””â”€â”€ shared/                  # Shared utilities
â”‚       â””â”€â”€ src/
â”‚           â”œâ”€â”€ types/           # Shared TypeScript types
â”‚           â”œâ”€â”€ validators/      # Shared validation logic
â”‚           â”œâ”€â”€ schemas/         # Shared schema definitions
â”‚           â””â”€â”€ __tests__/       # Tests for shared code
```

## Package Responsibilities

### Core (@cv-generator/core)

- DDD bounded contexts organization:
  - **CV Context**: Resume entities, business logic, validation
  - **Export Context**: Export formats, conversion management
  - **User Context**: User management, preferences
  - **Shared**: Shared utilities (Result, ValidationError)
- Explicit port interfaces for dependency inversion
- TypeScript aliases by business context

### UI (@cv-generator/ui)

- Vue.js components and composables
- State management with Pinia
- Styling with Tailwind CSS
- Co-located unit tests

### Infrastructure (@cv-generator/infrastructure)

- Repository implementations
- External services and adapters
- Data persistence (LocalStorage)
- Error handling

### Shared (@cv-generator/shared)

- Shared types and utilities
- Validation schemas
- Common interfaces
- Test utilities

## Coding Standards

### SOLID Principles

- **S - Single Responsibility**: Each class, module, and function should have one responsibility
  - Example: A service class should either handle business logic OR data access, not both
  - Services, repositories, entities should have focused responsibilities

- **O - Open/Closed**: Software entities should be open for extension, closed for modification
  - Example: Use inheritance and interfaces to extend functionality without modifying existing code
  - Prefer composition over inheritance when appropriate

- **L - Liskov Substitution**: Subtypes must be substitutable for their base types
  - Example: Child classes must maintain all behaviors of parent classes
  - Interface implementations must honor the contract of the interface

- **I - Interface Segregation**: Many specific interfaces are better than one general-purpose interface
  - Example: Define focused repository interfaces rather than one large repository interface
  - Break large interfaces into smaller, more focused ones

- **D - Dependency Inversion**: Depend on abstractions, not concretions
  - Example: Core domain code should depend on port interfaces, not implementations
  - Use dependency injection to provide implementations at runtime

### TypeScript & Type Safety

- NEVER use any type without explicit justification
- NEVER use non-suffixed interfaces or types
- NEVER mutate entity state directly
- NEVER expose internal implementation details
- NEVER use barrel files (index.ts)
- ALWAYS use proper type suffixes
- ALWAYS validate data at boundaries
- ALWAYS use immutable patterns
- ALWAYS document public APIs
- ALWAYS import directly from source files

### Testing Strategy

- TDD as primary approach
- Tests MUST be co-located with the code they test
- Each public method or component MUST have tests
- Use factory methods for test data
- Mock external dependencies
- Test files MUST follow the naming pattern `*.spec.ts` or `*.test.ts`

### Code Generation Standards

The project follows standards for efficient, maintainable code generation as defined in the [code generation standards](mdc:.cursor/rules/802-code-generation-standardized.mdc). Key principles include:

- Follow KISS (Keep It Simple, Stupid), YAGNI (You Aren't Gonna Need It), and DRY (Don't Repeat Yourself)
- Generate only the code necessary for implementing the current task
- Maintain consistency with existing code patterns and architecture
- Avoid over-engineering and premature optimization
- Ensure all generated code follows project naming conventions

### Naming Conventions

The project enforces consistent naming conventions as defined in the [naming conventions rule](mdc:.cursor/rules/002-naming-conventions.mdc). These conventions ensure readability, maintainability, and searchability of the codebase.

## Examples

<example>
// Good: Properly structured domain entity with encapsulated logic
// packages/core/src/cv/domain/entities/Resume.ts
export class Resume {
  private readonly id: string;
  private basics: Basics;
  private skills: Skill[];
  
  constructor(params: ResumeParams) {
    this.id = params.id ?? uuidv4();
    this.basics = new Basics(params.basics);
    this.skills = params.skills.map(skill => new Skill(skill));
  }
  
  public getId(): string {
    return this.id;
  }
  
  public updateBasics(basics: BasicsParams): Result<Basics, ValidationError> {
    const validatedBasics = BasicsSchema.safeParse(basics);
    
    if (!validatedBasics.success) {
      return Result.failure(new ValidationError(validatedBasics.error));
    }
    
    this.basics = new Basics(validatedBasics.data);
    return Result.success(this.basics);
  }
  
  public toDTO(): ResumeDTO {
    return {
      id: this.id,
      basics: this.basics.toDTO(),
      skills: this.skills.map(skill => skill.toDTO())
    };
  }
}
</example>

<example type="invalid">
// Bad: Anemic model with no encapsulation, direct mutation, and no validation
// Avoid this approach:
export class Resume {
  public id: string;
  public basics: any;
  public skills: any[];
  
  constructor(data: any) {
    this.id = data.id;
    this.basics = data.basics;
    this.skills = data.skills;
  }
}

// Direct mutation from outside
const resume = new Resume(data);
resume.basics.name = "New Name"; // Bad: Direct mutation of internal state
</example>

<version>2.3.0</version>